<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Timeline – perfekter Zoom</title>
<style>
body {
  margin: 0;
  background: linear-gradient(120deg, #a2c1d8, #c3d9e8);
  overflow: hidden;
}
#timeline-wrapper {
  width: 100%;
  height: 100vh;
  overflow: hidden;
  position: relative;
  cursor: grab;
}
#timeline {
  display: flex;
  height: 100%;
  transform-origin: 0 0;
  user-select: none;
}
#timeline img {
  height: 100%;
  display: block;
  flex-shrink: 0;
  object-fit: cover;
  -webkit-user-drag: none;
  user-drag: none;
}
</style>
</head>
<body>

<div id="timeline-wrapper">
  <div id="timeline"></div>
</div>

<script>
const wrapper = document.getElementById('timeline-wrapper');
const timeline = document.getElementById('timeline');
const totalPages = 17;
const extraMargin = 80;

// Bilder dynamisch laden
for (let i = 1; i <= totalPages; i++) {
  const img = document.createElement('img');
  img.src = `images/Seite${i}.png`;
  img.alt = `Seite ${i}`;
  timeline.appendChild(img);
}

let scale = 0.7;
let targetScale = 0.7;
let translateX = 0;
let translateY = 0;
let targetTranslateX = 0;
let targetTranslateY = 0;
let isDragging = false;
let startX, startY;

// Drag
wrapper.addEventListener('mousedown', e => {
  isDragging = true;
  startX = e.clientX - targetTranslateX;
  startY = e.clientY - targetTranslateY;
  wrapper.style.cursor = 'grabbing';
});
document.addEventListener('mouseup', () => {
  isDragging = false;
  wrapper.style.cursor = 'grab';
});
document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  targetTranslateX = e.clientX - startX;
  targetTranslateY = e.clientY - startY;
  applyBounds();
});

// Zoom auf Mauszeiger (präzise)
wrapper.addEventListener('wheel', e => {
  e.preventDefault();

  const rect = wrapper.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const prevScale = targetScale;
  const zoomFactor = Math.exp(-e.deltaY * 0.0015); // feiner & natürlich
  const newScale = Math.min(Math.max(0.3, targetScale * zoomFactor), 5);

  const dx = (mouseX - targetTranslateX) / prevScale;
  const dy = (mouseY - targetTranslateY) / prevScale;

  targetTranslateX = mouseX - dx * newScale;
  targetTranslateY = mouseY - dy * newScale;
  targetScale = newScale;

  applyBounds();
});

// Begrenzungen
function applyBounds() {
  const wrapperRect = wrapper.getBoundingClientRect();
  const timelineWidth = timeline.scrollWidth * targetScale;
  const timelineHeight = timeline.scrollHeight * targetScale;
  const minX = wrapperRect.width - timelineWidth - extraMargin;
  const maxX = extraMargin;
  const minY = wrapperRect.height - timelineHeight - extraMargin;
  const maxY = extraMargin;
  targetTranslateX = Math.min(maxX, Math.max(minX, targetTranslateX));
  targetTranslateY = Math.min(maxY, Math.max(minY, targetTranslateY));
}

// Sanfte Bewegung
function animate() {
  scale += (targetScale - scale) * 0.15;
  translateX += (targetTranslateX - translateX) * 0.15;
  translateY += (targetTranslateY - translateY) * 0.15;
  timeline.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
